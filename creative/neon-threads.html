<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Threads — Shadow's Garden</title>
<meta name="description" content="Glowing threads that dance and connect. Click to spawn, drag to influence.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body { margin: 0; overflow: hidden; background: #080810; }
  canvas { display: block; }
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
    z-index: 10;
  }
  button {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    transition: all 0.2s;
  }
  button:hover { background: rgba(255,255,255,0.2); }
  .info {
    position: fixed;
    top: 20px;
    left: 20px;
    color: rgba(255,255,255,0.4);
    font-size: 13px;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <canvas id="canvas"></canvas>
  <div class="info">Click to spawn threads • Drag to influence • Space to pause</div>
  <div class="controls">
    <button id="clear">Clear All</button>
    <button id="explode">Explode</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let threads = [];
    let mouseX = 0, mouseY = 0, mouseDown = false;
    let paused = false;
    
    const THREAD_COUNT = 40;
    const SEGMENTS = 20;
    const CONNECT_DIST = 80;
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    class Thread {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.segments = [];
        this.hue = Math.random() * 360;
        
        for (let i = 0; i < SEGMENTS; i++) {
          this.segments.push({
            x: x + i * 3,
            y: y,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            targetX: x + i * 3,
            targetY: y
          });
        }
      }
      
      update() {
        // Head follows previous segment or spawn point
        const head = this.segments[0];
        
        // Mouse influence
        if (mouseDown) {
          const dx = mouseX - head.x;
          const dy = mouseY - head.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 200) {
            head.vx += dx * 0.01;
            head.vy += dy * 0.01;
          }
        }
        
        // Spring physics
        head.vx += (this.x - head.x) * 0.05;
        head.vy += (this.y - head.y) * 0.05;
        head.vx *= 0.9;
        head.vy *= 0.9;
        head.x += head.vx;
        head.y += head.vy;
        
        // Rest follow with spring constraints
        for (let i = 1; i < this.segments.length; i++) {
          const prev = this.segments[i - 1];
          const curr = this.segments[i];
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          const dist = Math.hypot(dx, dy);
          const restLength = 8;
          
          if (dist > 0) {
            const diff = (dist - restLength) / dist;
            const offsetX = dx * diff * 0.5;
            const offsetY = dy * diff * 0.5;
            
            curr.x -= offsetX;
            curr.y -= offsetY;
            
            // Add some organic movement
            curr.vx += (Math.random() - 0.5) * 0.5;
            curr.vy += (Math.random() - 0.5) * 0.5;
            curr.vx *= 0.95;
            curr.vy *= 0.95;
            curr.x += curr.vx;
            curr.y += curr.vy;
          }
        }
      }
      
      draw() {
        ctx.beginPath();
        ctx.moveTo(this.segments[0].x, this.segments[0].y);
        
        for (let i = 1; i < this.segments.length; i++) {
          const prev = this.segments[i - 1];
          const curr = this.segments[i];
          const cpx = (prev.x + curr.x) / 2;
          const cpy = (prev.y + curr.y) / 2;
          ctx.quadraticCurveTo(prev.x, prev.y, cpx, cpy);
        }
        
        const gradient = ctx.createLinearGradient(
          this.segments[0].x, this.segments[0].y,
          this.segments[this.segments.length-1].x, this.segments[this.segments.length-1].y
        );
        gradient.addColorStop(0, `hsla(${this.hue}, 100%, 70%, 1)`);
        gradient.addColorStop(0.5, `hsla(${this.hue + 30}, 100%, 50%, 0.8)`);
        gradient.addColorStop(1, `hsla(${this.hue + 60}, 100%, 30%, 0.4)`);
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.stroke();
        
        // Glow
        ctx.shadowColor = `hsla(${this.hue}, 100%, 50%, 0.8)`;
        ctx.shadowBlur = 15;
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }
    
    function drawConnections() {
      for (let i = 0; i < threads.length; i++) {
        for (let j = i + 1; j < threads.length; j++) {
          const t1 = threads[i];
          const t2 = threads[j];
          
          const h1 = t1.segments[Math.floor(t1.segments.length / 2)];
          const h2 = t2.segments[Math.floor(t2.segments.length / 2)];
          
          const dx = h1.x - h2.x;
          const dy = h1.y - h2.y;
          const dist = Math.hypot(dx, dy);
          
          if (dist < CONNECT_DIST) {
            const alpha = 1 - dist / CONNECT_DIST;
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.3})`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(h1.x, h1.y);
            ctx.lineTo(h2.x, h2.y);
            ctx.stroke();
          }
        }
      }
    }
    
    function update() {
      if (paused) return;
      
      threads.forEach(t => t.update());
    }
    
    function draw() {
      ctx.fillStyle = 'rgba(8, 8, 16, 0.1)';
      ctx.fillRect(0, 0, width, height);
      
      drawConnections();
      threads.forEach(t => t.draw());
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // Initialize threads
    function initThreads() {
      threads = [];
      for (let i = 0; i < THREAD_COUNT; i++) {
        const x = Math.random() * width;
        const y = Math.random() * height;
        threads.push(new Thread(x, y));
      }
    }
    
    // Events
    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      mouseX = e.clientX;
      mouseY = e.clientY;
      threads.push(new Thread(e.clientX, e.clientY));
    });
    
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });
    
    canvas.addEventListener('mouseup', () => {
      mouseDown = false;
    });
    
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        paused = !paused;
        e.preventDefault();
      }
    });
    
    document.getElementById('clear').onclick = () => {
      threads = [];
    };
    
    document.getElementById('explode').onclick = () => {
      threads.forEach(t => {
        t.segments.forEach(s => {
          s.vx += (Math.random() - 0.5) * 20;
          s.vy += (Math.random() - 0.5) * 20;
        });
      });
    };
    
    window.addEventListener('resize', resize);
    resize();
    initThreads();
    animate();
  </script>
</body>
</html>
