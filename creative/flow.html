<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flow Field — Shadow's Garden</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { 
    background: #050505; 
    overflow: hidden;
    font-family: 'JetBrains Mono', monospace;
  }
  canvas { display: block; }
  .hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #222;
    font-size: 10px;
    pointer-events: none;
  }
  .title {
    position: fixed;
    top: 20px;
    left: 20px;
    color: #333;
    font-size: 11px;
    pointer-events: none;
  }
</style>
</head>
<body>
<div class="title">flow field</div>
<div class="hint">click to disturb · particles follow invisible currents</div>
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width, height;
let particles = [];
let cols, rows;
let resolution = 20;
let zoff = 0;
let flowfield;
let disturbances = [];

const particleCount = 1500;
const fadeRate = 0.05;

function resize() {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  cols = Math.floor(width / resolution);
  rows = Math.floor(height / resolution);
  initFlowfield();
  initParticles();
}

function initFlowfield() {
  flowfield = new Array(cols * rows);
}

function initParticles() {
  particles = [];
  for (let i = 0; i < particleCount; i++) {
    particles.push({
      x: Math.random() * width,
      y: Math.random() * height,
      prevX: 0,
      prevY: 0,
      speed: Math.random() * 1.5 + 0.5,
      color: Math.random()
    });
  }
}

function getIndex(col, row) {
  return col + row * cols;
}

function updateFlowfield() {
  let yoff = 0;
  for (let y = 0; y < rows; y++) {
    let xoff = 0;
    for (let x = 0; x < cols; x++) {
      const index = getIndex(x, y);
      
      // Check disturbances
      let angle = noise(xoff, yoff, zoff) * Math.PI * 4;
      
      for (const d of disturbances) {
        const dx = x * resolution + resolution/2 - d.x;
        const dy = y * resolution + resolution/2 - d.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < d.radius) {
          const influence = 1 - dist / d.radius;
          angle += d.strength * influence * Math.sin(Math.atan2(dy, dx));
        }
      }
      
      flowfield[index] = angle;
      xoff += 0.1;
    }
    yoff += 0.1;
  }
  zoff += 0.003;
}

function noise(x, y, z) {
  // Simple Perlin-like noise
  const p = 0.5;
  const sx = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719);
  return (Math.sin(sx * 43758.5453) + 1) / 2;
}

function updateParticles() {
  for (const p of particles) {
    p.prevX = p.x;
    p.prevY = p.y;
    
    const col = Math.floor(p.x / resolution);
    const row = Math.floor(p.y / resolution);
    
    if (col >= 0 && col < cols && row >= 0 && row < rows) {
      const index = getIndex(col, row);
      const angle = flowfield[index];
      
      p.x += Math.cos(angle) * p.speed;
      p.y += Math.sin(angle) * p.speed;
    }
    
    // Wrap around
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
  }
  
  // Fade disturbances
  for (let i = disturbances.length - 1; i >= 0; i--) {
    disturbances[i].radius *= 0.995;
    disturbances[i].strength *= 0.99;
    if (disturbances[i].strength < 0.1) {
      disturbances.splice(i, 1);
    }
  }
}

function draw() {
  // Semi-transparent fade
  ctx.fillStyle = `rgba(5, 5, 5, ${fadeRate})`;
  ctx.fillRect(0, 0, width, height);
  
  // Draw particles
  for (const p of particles) {
    const hue = (p.color * 60 + zoff * 50) % 360;
    const sat = 60 + p.color * 20;
    const light = 40 + p.color * 30;
    
    ctx.strokeStyle = `hsla(${hue}, ${sat}%, ${light}%, 0.6)`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(p.prevX, p.prevY);
    ctx.lineTo(p.x, p.y);
    ctx.stroke();
  }
}

function loop() {
  updateFlowfield();
  updateParticles();
  draw();
  requestAnimationFrame(loop);
}

canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  disturbances.push({
    x: e.clientX - rect.left,
    y: e.clientY - rect.top,
    radius: 150,
    strength: 8
  });
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  for (let i = 0; i < 5; i++) {
    disturbances.push({
      x: e.clientX + (Math.random() - 0.5) * 100,
      y: e.clientY + (Math.random() - 0.5) * 100,
      radius: 100 + Math.random() * 100,
      strength: 6 + Math.random() * 4
    });
  }
});

window.addEventListener('resize', resize);

resize();
loop();
</script>
</body>
</html>
