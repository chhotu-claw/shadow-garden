<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flow Fields — Shadow's Garden</title>
<meta name="description" content="Particles drift through Perlin noise flow fields. Mesmerizing generative art.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body { margin: 0; overflow: hidden; background: #050508; }
  canvas { display: block; }
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    z-index: 10;
  }
  button {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
  }
  button:hover { background: rgba(255,255,255,0.2); }
  .info {
    position: fixed;
    top: 20px;
    left: 20px;
    color: rgba(255,255,255,0.4);
    font-size: 13px;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <canvas id="canvas"></canvas>
  <div class="info">Click to reset • Drag to influence • Space to pause</div>
  <div class="controls">
    <button id="clear">Clear</button>
    <button id="colors1">Neon</button>
    <button id="colors2">Ocean</button>
    <button id="colors3">Fire</button>
    <button id="colors4">Mono</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let particles = [];
    let colorScheme = 'neon';
    let paused = false;
    let mouseX = 0, mouseY = 0, mouseDown = false;
    
    const NUM_PARTICLES = 3000;
    const SCALE = 0.005;
    const SPEED = 2;
    
    const colorSchemes = {
      neon: ['#ff006e', '#8338ec', '#3a86ff', '#06d6a0', '#ffbe0b'],
      ocean: ['#023e8a', '#0077b6', '#0096c7', '#48cae4', '#ade8f4'],
      fire: ['#370617', '#6a040f', '#9d0208', '#d00000', '#dc2f02'],
      mono: ['#ffffff', '#cccccc', '#999999', '#666666', '#333333']
    };
    
    // Perlin noise implementation
    const perm = new Uint8Array(512);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [p[i], p[j]] = [p[j], p[i]];
    }
    for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
    
    const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
    const dot3 = (g, x, y, z) => g[0]*x + g[1]*y + g[2]*z;
    
    function noise(x, y, z = 0) {
      const F3 = 1/3, G3 = 1/6;
      const s = (x+y+z)*F3;
      const i = Math.floor(x+s), j = Math.floor(y+s), k = Math.floor(z+s);
      const t = (i+j+k)*G3;
      const x0 = x-(i-t), y0 = y-(j-t), z0 = z-(k-t);
      
      let i1, j1, k1, i2, j2, k2;
      if (x0>=y0) {
        if (y0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
        else if (x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
        else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
      } else {
        if (y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
        else if (x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
        else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
      }
      
      const x1 = x0-i1+G3, y1 = y0-j1+G3, z1 = z0-k1+G3;
      const x2 = x0-i2+2*G3, y2 = y0-j2+2*G3, z2 = z0-k2+2*G3;
      const x3 = x0-1+3*G3, y3 = y0-1+3*G3, z3 = z0-1+3*G3;
      
      const ii = i&255, jj = j&255, kk = k&255;
      const gi0 = perm[ii+perm[jj+perm[kk]]] % 12;
      const gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;
      const gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;
      const gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;
      
      let n0, n1, n2, n3;
      let t0 = 0.6-x0*x0-y0*y0-z0*z0;
      n0 = t0<0 ? 0 : (t0*=t0, t0*t0*dot3(grad3[gi0],x0,y0,z0));
      let t1 = 0.6-x1*x1-y1*y1-z1*z1;
      n1 = t1<0 ? 0 : (t1*=t1, t1*t1*dot3(grad3[gi1],x1,y1,z1));
      let t2 = 0.6-x2*x2-y2*y2-z2*z2;
      n2 = t2<0 ? 0 : (t2*=t2, t2*t2*dot3(grad3[gi2],x2,y2,z2));
      let t3 = 0.6-x3*x3-y3*y3-z3*z3;
      n3 = t3<0 ? 0 : (t3*=t3, t3*t3*dot3(grad3[gi3],x3,y3,z3));
      
      return 32*(n0+n1+n2+n3);
    }
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    class Particle {
      constructor() {
        this.reset();
      }
      
      reset() {
        this.x = Math.random() * width;
        this.y = Math.random() * height;
        this.speed = 0.5 + Math.random() * 1.5;
        this.age = 0;
        this.maxAge = 200 + Math.random() * 300;
      }
      
      update() {
        const angle = noise(this.x * SCALE, this.y * SCALE, Date.now() * 0.0001) * Math.PI * 4;
        
        this.x += Math.cos(angle) * this.speed * SPEED;
        this.y += Math.sin(angle) * this.speed * SPEED;
        
        // Mouse influence
        if (mouseDown) {
          const dx = mouseX - this.x;
          const dy = mouseY - this.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 200) {
            this.x += dx * 0.02;
            this.y += dy * 0.02;
          }
        }
        
        // Wrap or reset
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height || this.age > this.maxAge) {
          this.reset();
        }
        
        this.age++;
      }
      
      draw() {
        const colors = colorSchemes[colorScheme];
        const t = this.age / this.maxAge;
        const idx = Math.floor(t * colors.length);
        const alpha = Math.sin(t * Math.PI) * 0.8;
        
        ctx.fillStyle = colors[idx] + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(this.x, this.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function init() {
      particles = [];
      for (let i = 0; i < NUM_PARTICLES; i++) {
        particles.push(new Particle());
      }
    }
    
    function update() {
      if (paused) return;
      particles.forEach(p => p.update());
    }
    
    function draw() {
      ctx.fillStyle = 'rgba(5, 5, 8, 0.05)';
      ctx.fillRect(0, 0, width, height);
      particles.forEach(p => p.draw());
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    canvas.addEventListener('mousedown', (e) => { mouseDown = true; mouseX = e.clientX; mouseY = e.clientY; });
    canvas.addEventListener('mousemove', (e) => { mouseX = e.clientX; mouseY = e.clientY; });
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('mouseleave', () => mouseDown = false);
    canvas.addEventListener('click', () => init());
    
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { paused = !paused; e.preventDefault(); }
    });
    
    document.getElementById('clear').onclick = init;
    document.getElementById('colors1').onclick = () => colorScheme = 'neon';
    document.getElementById('colors2').onclick = () => colorScheme = 'ocean';
    document.getElementById('colors3').onclick = () => colorScheme = 'fire';
    document.getElementById('colors4').onclick = () => colorScheme = 'mono';
    
    window.addEventListener('resize', resize);
    resize();
    init();
    animate();
  </script>
</body>
</html>
