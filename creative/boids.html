<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Boids Flocking — Shadow's Garden</title>
<meta name="description" description Emergent flocking behavior from three simple rules: separation, alignment, and cohesion.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body { margin: 0; overflow: hidden; background: #050508; }
  canvas { display: block; }
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    z-index: 10;
  }
  button {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
  }
  button:hover { background: rgba(255,255,255,0.2); }
  .info {
    position: fixed;
    top: 20px;
    left: 20px;
    color: rgba(255,255,255,0.4);
    font-size: 13px;
    font-family: monospace;
  }
  .sliders {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
  }
  .slider-row {
    display: flex;
    align-items: center;
    gap: 8px;
    color: rgba(255,255,255,0.5);
    font-size: 12px;
  }
  input[type="range"] { width: 100px; }
</style>
</head>
<body data-page-type="app">
  <canvas id="canvas"></canvas>
  <div class="info">Click to add boids • Drag to create flock</div>
  <div class="sliders">
    <div class="slider-row">Separation: <input type="range" id="sep" min="0" max="5" step="0.1" value="2"></div>
    <div class="slider-row">Alignment: <input type="range" id="ali" min="0" max="5" step="0.1" value="1"></div>
    <div class="slider-row">Cohesion: <input type="range" id="coh" min="0" max="5" step="0.1" value="1"></div>
  </div>
  <div class="controls">
    <button id="clear">Clear</button>
    <button id="predator">Add Predator</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let boids = [];
    let predator = null;
    let mouseX = 0, mouseY = 0, mouseDown = false;
    
    const NUM_BOIDS = 300;
    const PERCEPTION = 50;
    const MAX_SPEED = 4;
    const MAX_FORCE = 0.1;
    
    let separation = 2, alignment = 1, cohesion = 1;
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    class Boid {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * MAX_SPEED * 2;
        this.vy = (Math.random() - 0.5) * MAX_SPEED * 2;
        this.hue = Math.random() * 60 + 200;
      }
      
      edges() {
        if (this.x > width) this.x = 0;
        if (this.x < 0) this.x = width;
        if (this.y > height) this.y = 0;
        if (this.y < 0) this.y = height;
      }
      
      align(boids) {
        let steering = { vx: 0, vy: 0 };
        let total = 0;
        for (const other of boids) {
          const d = Math.hypot(this.x - other.x, this.y - other.y);
          if (other !== this && d < PERCEPTION) {
            steering.vx += other.vx;
            steering.vy += other.vy;
            total++;
          }
        }
        if (total > 0) {
          steering.vx /= total;
          steering.vy /= total;
          const mag = Math.hypot(steering.vx, steering.vy);
          if (mag > 0) {
            steering.vx = (steering.vx / mag) * MAX_SPEED;
            steering.vy = (steering.vy / mag) * MAX_SPEED;
            steering.vx -= this.vx;
            steering.vy -= this.vy;
          }
        }
        return steering;
      }
      
      cohesion(boids) {
        let steering = { x: 0, y: 0 };
        let total = 0;
        for (const other of boids) {
          const d = Math.hypot(this.x - other.x, this.y - other.y);
          if (other !== this && d < PERCEPTION) {
            steering.x += other.x;
            steering.y += other.y;
            total++;
          }
        }
        if (total > 0) {
          steering.x /= total;
          steering.y /= total;
          steering.x -= this.x;
          steering.y -= this.y;
          const mag = Math.hypot(steering.x, steering.y);
          if (mag > 0) {
            steering.x = (steering.x / mag) * MAX_SPEED;
            steering.y = (steering.y / mag) * MAX_SPEED;
            steering.x -= this.vx;
            steering.y -= this.vy;
          }
        }
        return steering;
      }
      
      separation(boids) {
        let steering = { vx: 0, vy: 0 };
        let total = 0;
        for (const other of boids) {
          const d = Math.hypot(this.x - other.x, this.y - other.y);
          if (other !== this && d < PERCEPTION / 2) {
            let diff = { vx: this.x - other.x, vy: this.y - other.y };
            const mag = Math.hypot(diff.vx, diff.vy);
            if (mag > 0) {
              diff.vx /= mag;
              diff.vy /= mag;
            }
            diff.vx /= d;
            diff.vy /= d;
            steering.vx += diff.vx;
            steering.vy += diff.vy;
            total++;
          }
        }
        if (total > 0) {
          steering.vx /= total;
          steering.vy /= total;
          const mag = Math.hypot(steering.vx, steering.vy);
          if (mag > 0) {
            steering.vx = (steering.vx / mag) * MAX_SPEED;
            steering.vy = (steering.vy / mag) * MAX_SPEED;
            steering.vx -= this.vx;
            steering.vy -= this.vy;
          }
        }
        return steering;
      }
      
      flee(target) {
        if (!target) return { vx: 0, vy: 0 };
        let d = Math.hypot(this.x - target.x, this.y - target.y);
        if (d < 150) {
          let steering = { vx: this.x - target.x, vy: this.y - target.y };
          const mag = Math.hypot(steering.vx, steering.vy);
          if (mag > 0) {
            steering.vx = (steering.vx / mag) * MAX_SPEED * 1.5;
            steering.vy = (steering.vy / mag) * MAX_SPEED * 1.5;
            steering.vx -= this.vx;
            steering.vy -= this.vy;
          }
          return steering;
        }
        return { vx: 0, vy: 0 };
      }
      
      flock(boids) {
        let ali = this.align(boids);
        let coh = this.cohesion(boids);
        let sep = this.separation(boids);
        let flee = this.flee(predator);
        
        ali.vx *= alignment; ali.vy *= alignment;
        coh.vx *= cohesion; coh.vy *= cohesion;
        sep.vx *= separation; sep.vy *= separation;
        flee.vx *= 3; flee.vy *= 3;
        
        this.vx += ali.vx + coh.vx + sep.vx + flee.vx;
        this.vy += ali.vy + coh.vy + sep.vy + flee.vy;
        
        const speed = Math.hypot(this.vx, this.vy);
        if (speed > MAX_SPEED) {
          this.vx = (this.vx / speed) * MAX_SPEED;
          this.vy = (this.vy / speed) * MAX_SPEED;
        }
      }
      
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.edges();
      }
      
      draw() {
        const angle = Math.atan2(this.vy, this.vx);
        
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(angle);
        
        ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, 0.8)`;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-6, 4);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-6, -4);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
    }
    
    function init() {
      boids = [];
      for (let i = 0; i < NUM_BOIDS; i++) {
        boids.push(new Boid(Math.random() * width, Math.random() * height));
      }
    }
    
    function update() {
      boids.forEach(b => {
        b.flock(boids);
        b.update();
      });
      
      if (predator) {
        predator.x += predator.vx;
        predator.y += predator.vy;
        
        if (predator.x > width) predator.x = 0;
        if (predator.x < 0) predator.x = width;
        if (predator.y > height) predator.y = 0;
        if (predator.y < 0) predator.y = height;
      }
    }
    
    function draw() {
      ctx.fillStyle = 'rgba(5, 5, 8, 0.2)';
      ctx.fillRect(0, 0, width, height);
      
      boids.forEach(b => b.draw());
      
      if (predator) {
        ctx.fillStyle = '#ff4444';
        ctx.beginPath();
        ctx.arc(predator.x, predator.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'rgba(255, 68, 68, 0.3)';
        ctx.beginPath();
        ctx.arc(predator.x, predator.y, 150, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      for (let i = 0; i < 10; i++) {
        boids.push(new Boid(e.clientX + (Math.random()-0.5)*50, e.clientY + (Math.random()-0.5)*50));
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });
    
    canvas.addEventListener('mouseup', () => mouseDown = false);
    
    document.getElementById('clear').onclick = init;
    document.getElementById('predator').onclick = () => {
      predator = {
        x: Math.random() * width,
        y: Math.random() * height,
        vx: (Math.random() - 0.5) * 3,
        vy: (Math.random() - 0.5) * 3
      };
    };
    
    document.getElementById('sep').oninput = (e) => separation = +e.target.value;
    document.getElementById('ali').oninput = (e) => alignment = +e.target.value;
    document.getElementById('coh').oninput = (e) => cohesion = +e.target.value;
    
    window.addEventListener('resize', resize);
    resize();
    init();
    animate();
  </script>
</body>
</html>
