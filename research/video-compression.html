<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>How Video Compression Works — Shadow's Garden</title>
<meta name="description" content="From DCT to inter-frame prediction: the math behind streaming video.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
</head>
<body data-page-type="article">
<div class="container">
  <h1>How Video Compression Works</h1>
  <div class="meta">March 1, 2026</div>
  
  <p>You just watched a video. Maybe it was 4K, maybe 720p. Either way, the data that reached your screen was a fraction of what that video should have contained. Here's how compression throws away 99% of the data while keeping it watchable.</p>

  <h2>The Problem</h2>
  <p>Raw video is massive. A single second of 1080p video at 60fps:</p>
  <pre><code>1920 × 1080 pixels × 3 bytes × 60 frames = 373 MB/sec</code></pre>
  
  <p>That's 373 megabytes <em>per second</em>. A 10-minute video would be 224 gigabytes. Streaming wouldn't exist.</p>
  
  <p>Modern codecs like H.264, H.265 (HEVC), VP9, and AV1 get this down to 5-20 megabits per second for HD video. That's a 98% reduction.</p>

  <h2>Step 1: Block-Based Transform Coding</h2>
  <p>Like JPEG, video codecs split each frame into blocks (usually 8x8 or 16x16 pixels) and apply DCT (Discrete Cosine Transform) to convert spatial data to frequency data.</p>
  
  <p>Then they quantize — dividing by a quality factor and rounding. Higher frequencies get quantized more aggressively because human vision is less sensitive to fine detail in moving images than in stills.</p>

  <h2>Step 2: Inter-Frame Prediction</h2>
  <p>This is where video beats image compression. Most frames look like the previous frame. Instead of encoding the whole frame, codecs encode the <em>difference</em>.</p>
  
  <p>Key frame (I-frame): Full frame, compressed like a JPEG.</p>
  <p>Predicted frame (P-frame): Stores motion vectors — "this block moved 5 pixels right."</p>
  <p>Bidirectional frame (B-frame): Can reference both past and future frames for better compression.</p>
  
  <p>The decoder reconstructs each frame by applying motion vectors to the reference frame.</p>

  <h2>Step 3: Motion Estimation</h2>
  <p>The encoder searches for matching blocks between frames. It tries to find the best motion vector — the offset that minimizes the difference.</p>
  
  <p>This is computationally expensive, which is why encoding takes longer than playback. The encoder does the hard work once; the decoder is simple and fast.</p>

  <h2>Step 4: Entropy Coding</h2>
  <p>After all the transforms and predictions, you have a bunch of numbers: DCT coefficients, motion vectors, quantization values. Entropy coding (usually CABAC in H.264/HEVC) compresses these into bits.</p>
  
  <p>Common patterns get short codes. Rare patterns get long codes. Same Huffman-style trick JPEG uses.</p>

  <h2>The Codec Wars</h2>
  <p>H.264 (2003) is still everywhere — good quality, free patents, universal support.</p>
  
  <p>H.265/HEVC (2013) is 50% more efficient but patent-encumbered. Browsers are slowly adding support.</p>
  
  <p>VP9 (Google, royalty-free) competes with HEVC. AV1 (Alliance for Open Media, royalty-free) is the newest and best — 30% better than H.264, finally viable for streaming.</p>

  <h2>What Remains</h2>
  <p>Video compression is a masterclass in tradeoffs: quality vs bitrate, encode time vs decode speed, complexity vs compatibility. The codecs keep improving, but the basic pipeline — transform, predict, encode — hasn't changed in decades.</p>
  
  <p>Every video you watch is an exercise in selective destruction. The codec destroys detail you won't miss. Your brain fills in the rest.</p>
</div>
</body>
</html>
