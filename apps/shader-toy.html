<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Shader Toy — Shadow's Garden</title>
<meta name="description">Write and run custom GLSL shaders in real-time. Interactive shader editor with presets.</meta>
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #0a0a0f;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
  }
  h1 {
    color: #e0e0e0;
    font-size: 1.8rem;
    margin-bottom: 5px;
    font-weight: 300;
  }
  .subtitle {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 20px;
  }
  .container {
    display: flex;
    gap: 20px;
    width: 100%;
    max-width: 1400px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .editor-panel {
    flex: 1;
    min-width: 400px;
    display: flex;
    flex-direction: column;
  }
  .preview-panel {
    flex: 1;
    min-width: 400px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  canvas {
    border: 1px solid #333;
    border-radius: 4px;
    cursor: crosshair;
    box-shadow: 0 0 30px rgba(0,0,0,0.5);
  }
  textarea {
    width: 100%;
    height: 400px;
    background: #0d0d12;
    color: #a0a0a0;
    border: 1px solid #333;
    border-radius: 4px;
    padding: 15px;
    font-family: 'Fira Code', 'Consolas', monospace;
    font-size: 12px;
    line-height: 1.5;
    resize: vertical;
    outline: none;
  }
  textarea:focus {
    border-color: #555;
  }
  .controls {
    display: flex;
    gap: 10px;
    margin-top: 15px;
    flex-wrap: wrap;
  }
  select, button {
    background: #1a1a20;
    color: #ccc;
    border: 1px solid #333;
    padding: 8px 14px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
  }
  button:hover {
    background: #252530;
    border-color: #555;
  }
  .error {
    color: #ff6b6b;
    font-size: 0.8rem;
    margin-top: 10px;
    font-family: monospace;
    white-space: pre-wrap;
    max-height: 100px;
    overflow-y: auto;
  }
  .info {
    color: #666;
    font-size: 0.75rem;
    margin-top: 10px;
    font-family: monospace;
  }
  .presets {
    display: flex;
    gap: 8px;
    margin-bottom: 15px;
    flex-wrap: wrap;
  }
  .presets button {
    padding: 6px 12px;
    font-size: 0.75rem;
  }
  .vars {
    color: #6bcb77;
  }
  .types {
    color: #4d96ff;
  }
</style>
</head>
<body data-page-type="app">
  <h1>Shader Toy</h1>
  <div class="subtitle">Write and run custom GLSL in real-time</div>
  
  <div class="container">
    <div class="editor-panel">
      <div class="presets">
        <button onclick="loadPreset('plasma')">Plasma</button>
        <button onclick="loadPreset('waves')">Waves</button>
        <button onclick="loadPreset('noise')">Noise</button>
        <button onclick="loadPreset('mandelbrot')">Mandelbrot</button>
        <button onclick="loadPreset('rays')">Rays</button>
        <button onclick="loadPreset('kaleido')">Kaleidoscope</button>
      </div>
      <textarea id="shaderCode" spellcheck="false"></textarea>
      <div class="controls">
        <button onclick="compile()">▶ Run Shader</button>
        <button onclick="resetCode()">Reset</button>
      </div>
      <div class="error" id="error"></div>
    </div>
    
    <div class="preview-panel">
      <canvas id="canvas" width="500" height="500"></canvas>
      <div class="info">
        <span class="vars">u_time</span> <span class="types">float</span> — time in seconds<br>
        <span class="vars">u_resolution</span> <span class="types">vec2</span> — canvas size<br>
        <span class="vars">u_mouse</span> <span class="types">vec2</span> — mouse position (0-1)
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    const codeEl = document.getElementById('shaderCode');
    const errorEl = document.getElementById('error');
    
    let program, startTime;
    let mouseX = 0.5, mouseY = 0.5;
    
    const vertexShaderSrc = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;
    
    const defaultFrag = `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec3 col = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0, 2, 4));
  gl_FragColor = vec4(col, 1.0);
}
`;

    const presets = {
      plasma: `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  float t = u_time * 0.5;
  
  float v = 0.0;
  v += sin((uv.x * 10.0 + t));
  v += sin((uv.y * 10.0 + t) * 0.5);
  v += sin((uv.x * 10.0 + uv.y * 10.0 + t) * 0.5);
  
  vec2 p = uv - 0.5;
  float cx = uv.x + sin(t * 0.5) * 0.5;
  float cy = uv.y + cos(t * 0.3) * 0.5;
  v += sin(sqrt(100.0 * (p.x * p.x + cy * cy) + 1.0) + t);
  
  v = v * 0.5;
  float r = sin(v * 3.14159);
  float g = sin(v * 3.14159 + 2.0);
  float b = sin(v * 3.14159 + 4.0);
  
  gl_FragColor = vec4(r, g, b, 1.0);
}
`,
      waves: `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec2 p = uv * 6.0 - 3.0;
  
  float r = length(p);
  float a = atan(p.y, p.x);
  
  float wave = sin(r * 8.0 - u_time * 2.0 + a * 3.0);
  float wave2 = sin(r * 12.0 + u_time * 1.5 - a * 5.0);
  
  vec3 col = 0.5 + 0.5 * cos(vec3(0.0, 0.3, 0.6) + wave + wave2);
  col *= 1.0 - r * 0.15;
  
  gl_FragColor = vec4(col, 1.0);
}
`,
      noise: `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  f = f * f * (3.0 - 2.0 * f);
  
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  
  return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
}

float fbm(vec2 p) {
  float v = 0.0;
  float a = 0.5;
  for (int i = 0; i < 5; i++) {
    v += a * noise(p);
    p *= 2.0;
    a *= 0.5;
  }
  return v;
}

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  float t = u_time * 0.3;
  
  vec2 p = uv * 4.0;
  p.x += sin(t) * 0.5;
  p.y += cos(t * 0.7) * 0.5;
  
  float n = fbm(p);
  vec3 col = vec3(n * 0.5 + 0.5);
  col = mix(col, vec3(n, n * 0.8, n * 0.5), sin(t) * 0.5 + 0.5);
  
  gl_FragColor = vec4(col, 1.0);
}
`,
      mandelbrot: `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

void main() {
  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / min(u_resolution.x, u_resolution.y);
  vec2 c = uv * 3.0 - 0.5;
  c.x += sin(u_time * 0.1) * 0.1;
  
  vec2 z = vec2(0.0);
  float iter = 0.0;
  
  for (float i = 0.0; i < 100.0; i++) {
    z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
    if (length(z) > 4.0) break;
    iter++;
  }
  
  float t = iter / 100.0;
  vec3 col = vec3(
    sin(t * 6.0 + 0.0),
    sin(t * 6.0 + 2.0),
    sin(t * 6.0 + 4.0)
  ) * 0.5 + 0.5;
  
  if (iter >= 100.0) col = vec3(0.0);
  
  gl_FragColor = vec4(col, 1.0);
}
`,
      rays: `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec2 p = uv - 0.5;
  
  float angle = atan(p.y, p.x);
  float r = length(p);
  
  float rays = 0.0;
  for (float i = 0.0; i < 12.0; i++) {
    float a = i * 3.14159 / 6.0 + u_time * 0.2;
    float d = abs(sin(angle - a));
    rays += 0.01 / (d + r * 2.0);
  }
  
  vec3 col = vec3(0.02, 0.01, 0.05);
  col += vec3(1.0, 0.6, 0.2) * rays;
  col += vec3(0.1, 0.05, 0.15) * rays * 0.5;
  
  gl_FragColor = vec4(col, 1.0);
}
`,
      kaleido: `
precision mediump float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;

void main() {
  vec2 uv = gl_FragCoord.xy / u_resolution;
  vec2 p = uv - 0.5;
  
  float angle = atan(p.y, p.x);
  float r = length(p);
  
  float segments = 6.0;
  angle = mod(angle, 3.14159 * 2.0 / segments);
  angle = abs(angle - 3.14159 / segments);
  
  vec2 q = vec2(cos(angle), sin(angle)) * r;
  
  float t = u_time * 0.5;
  float pattern = sin(q.x * 20.0 + t) * sin(q.y * 20.0 - t);
  pattern = pattern * 0.5 + 0.5;
  
  vec3 col = vec3(
    sin(pattern * 6.0 + t),
    sin(pattern * 6.0 + t + 2.0),
    sin(pattern * 6.0 + t + 4.0)
  ) * 0.5 + 0.5;
  
  gl_FragColor = vec4(col, 1.0);
}
`
    };

    function createShader(type, source) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const err = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new Error(err);
      }
      return shader;
    }

    function compile() {
      errorEl.textContent = '';
      const fragSrc = codeEl.value;
      
      try {
        const vs = createShader(gl.VERTEX_SHADER, vertexShaderSrc);
        const fs = createShader(gl.FRAGMENT_SHADER, fragSrc);
        
        if (program) gl.deleteProgram(program);
        
        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          throw new Error(gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
          -1, -1, 1, -1, -1, 1,
          -1, 1, 1, -1, 1, 1
        ]), gl.STATIC_DRAW);
        
        const posLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        
      } catch (e) {
        errorEl.textContent = e.message;
      }
    }

    function render() {
      if (!program) return;
      
      gl.viewport(0, 0, canvas.width, canvas.height);
      
      const timeLoc = gl.getUniformLocation(program, 'u_time');
      const resLoc = gl.getUniformLocation(program, 'u_resolution');
      const mouseLoc = gl.getUniformLocation(program, 'u_mouse');
      
      gl.uniform1f(timeLoc, (performance.now() - startTime) / 1000);
      gl.uniform2f(resLoc, canvas.width, canvas.height);
      gl.uniform2f(mouseLoc, mouseX, mouseY);
      
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      
      requestAnimationFrame(render);
    }

    function loadPreset(name) {
      codeEl.value = presets[name];
      compile();
    }

    function resetCode() {
      codeEl.value = defaultFrag;
      compile();
    }

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) / rect.width;
      mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
    });

    // Init
    codeEl.value = defaultFrag;
    startTime = performance.now();
    
    try {
      compile();
      render();
    } catch (e) {
      errorEl.textContent = e.message;
    }
  </script>
</body>
</html>
