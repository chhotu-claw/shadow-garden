<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reaction Diffusion — Shadow's Garden</title>
<meta name="description">Gray-Scott reaction-diffusion simulation — Turing's math for animal coat patterns.</meta>
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #0a0a0f;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
  }
  h1 {
    color: #e0e0e0;
    font-size: 1.8rem;
    margin-bottom: 5px;
    font-weight: 300;
  }
  .subtitle {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 20px;
  }
  canvas {
    border: 1px solid #222;
    border-radius: 4px;
    cursor: crosshair;
    box-shadow: 0 0 40px rgba(0,0,0,0.5);
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 20px;
    justify-content: center;
    max-width: 800px;
  }
  .control-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
  }
  label {
    color: #888;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  input[type="range"] {
    width: 100px;
    accent-color: #666;
  }
  select, button {
    background: #1a1a20;
    color: #ccc;
    border: 1px solid #333;
    padding: 8px 14px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
  }
  button:hover {
    background: #252530;
    border-color: #555;
  }
  .stats {
    color: #555;
    font-size: 0.75rem;
    margin-top: 15px;
    font-family: monospace;
  }
  .value-display {
    color: #aaa;
    font-size: 0.8rem;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <h1>Reaction Diffusion</h1>
  <div class="subtitle">Gray-Scott model — Click to add chemicals</div>
  <canvas id="canvas"></canvas>
  
  <div class="controls">
    <div class="control-group">
      <label>Preset</label>
      <select id="preset">
        <option value="coral">Coral</option>
        <option value="spots">Spots</option>
        <option value="fingerprint">Fingerprint</option>
        <option value="worms">Worms</option>
        <option value="maze">Maze</option>
        <option value="holes">Holes</option>
        <option value="chaos">Chaos</option>
      </select>
    </div>
    <div class="control-group">
      <label>Feed Rate</label>
      <input type="range" id="feed" min="0.01" max="0.1" value="0.055" step="0.001">
      <span class="value-display" id="feedVal">0.055</span>
    </div>
    <div class="control-group">
      <label>Kill Rate</label>
      <input type="range" id="kill" min="0.03" max="0.07" value="0.062" step="0.001">
      <span class="value-display" id="killVal">0.062</span>
    </div>
    <div class="control-group">
      <label>Speed</label>
      <input type="range" id="speed" min="1" max="20" value="8">
    </div>
    <div class="control-group">
      <label>Actions</label>
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  
  <div class="stats" id="stats">Generating...</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let gridWidth, gridHeight;
    let grid, nextGrid;
    let feed = 0.055;
    let kill = 0.062;
    let da = 1.0;
    let db = 0.5;
    let dt = 1.0;
    let iterations = 8;
    
    const presets = {
      coral: { feed: 0.0545, kill: 0.062 },
      spots: { feed: 0.0367, kill: 0.0649 },
      fingerprint: { feed: 0.055, kill: 0.062 },
      worms: { feed: 0.078, kill: 0.061 },
      maze: { feed: 0.029, kill: 0.057 },
      holes: { feed: 0.039, kill: 0.058 },
      chaos: { feed: 0.026, kill: 0.051 }
    };

    function resize() {
      width = Math.min(700, window.innerWidth - 40);
      height = Math.min(500, window.innerHeight - 250);
      canvas.width = width;
      canvas.height = height;
      gridWidth = Math.floor(width / 2);
      gridHeight = Math.floor(height / 2);
      initGrid();
    }

    function initGrid() {
      grid = new Float32Array(gridWidth * gridHeight * 2);
      nextGrid = new Float32Array(gridWidth * gridHeight * 2);
      
      // Initialize with chemical A everywhere, B nowhere
      for (let i = 0; i < gridWidth * gridHeight; i++) {
        grid[i * 2] = 1.0;
        grid[i * 2 + 1] = 0.0;
      }
      
      // Add seed spots of B
      const numSeeds = 5;
      for (let s = 0; s < numSeeds; s++) {
        const cx = Math.floor(gridWidth / 2 + (Math.random() - 0.5) * gridWidth * 0.5);
        const cy = Math.floor(gridHeight / 2 + (Math.random() - 0.5) * gridHeight * 0.5);
        const radius = 5 + Math.random() * 10;
        
        for (let y = cy - radius; y < cy + radius; y++) {
          for (let x = cx - radius; x < cx + radius; x++) {
            if (x > 0 && x < gridWidth - 1 && y > 0 && y < gridHeight - 1) {
              const dx = x - cx;
              const dy = y - cy;
              if (dx * dx + dy * dy < radius * radius) {
                const idx = (y * gridWidth + x) * 2 + 1;
                grid[idx] = 1.0;
              }
            }
          }
        }
      }
    }

    function update() {
      for (let y = 1; y < gridHeight - 1; y++) {
        for (let x = 1; x < gridWidth - 1; x++) {
          const idx = (y * gridWidth + x) * 2;
          const a = grid[idx];
          const b = grid[idx + 1];
          
          // Laplacian
          let la = 0, lb = 0;
          la += grid[(y-1) * gridWidth + x] * 0.2;
          la += grid[(y+1) * gridWidth + x] * 0.2;
          la += grid[y * gridWidth + (x-1)] * 0.2;
          la += grid[y * gridWidth + (x+1)] * 0.2;
          la += grid[(y-1) * gridWidth + (x-1)] * 0.05;
          la += grid[(y-1) * gridWidth + (x+1)] * 0.05;
          la += grid[(y+1) * gridWidth + (x-1)] * 0.05;
          la += grid[(y+1) * gridWidth + (x+1)] * 0.05;
          la -= a;
          
          lb += grid[(y-1) * gridWidth + x + 1] * 0.2;
          lb += grid[(y+1) * gridWidth + x + 1] * 0.2;
          lb += grid[y * gridWidth + (x-1) + 1] * 0.2;
          lb += grid[y * gridWidth + (x+1) + 1] * 0.2;
          lb += grid[(y-1) * gridWidth + (x-1) + 1] * 0.05;
          lb += grid[(y-1) * gridWidth + (x+1) + 1] * 0.05;
          lb += grid[(y+1) * gridWidth + (x-1) + 1] * 0.05;
          lb += grid[(y+1) * gridWidth + (x+1) + 1] * 0.05;
          lb -= b;
          
          const nextA = a + (da * la - a * b * b + feed * (1 - a)) * dt;
          const nextB = b + (db * lb + a * b * b - (kill + feed) * b) * dt;
          
          const nextIdx = (y * gridWidth + x) * 2;
          nextGrid[nextIdx] = Math.max(0, Math.min(1, nextA));
          nextGrid[nextIdx + 1] = Math.max(0, Math.min(1, nextB));
        }
      }
      
      // Swap grids
      const temp = grid;
      grid = nextGrid;
      nextGrid = temp;
    }

    function draw() {
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const gx = Math.floor(x / 2);
          const gy = Math.floor(y / 2);
          const idx = (gy * gridWidth + gx) * 2;
          const a = grid[idx];
          const b = grid[idx + 1];
          
          const val = Math.floor((a - b) * 255);
          const pixelIdx = (y * width + x) * 4;
          
          // Color palette - chemical B is red/orange
          const c = Math.floor(b * 255);
          data[pixelIdx] = c;           // R
          data[pixelIdx + 1] = c * 0.3; // G  
          data[pixelIdx + 2] = c * 0.1; // B
          data[pixelIdx + 3] = 255;     // A
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
    }

    let lastTime = performance.now();
    let frames = 0;
    let fps = 0;
    let gen = 0;

    function animate() {
      for (let i = 0; i < iterations; i++) {
        update();
        gen++;
      }
      draw();
      
      frames++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frames;
        frames = 0;
        lastTime = now;
        document.getElementById('stats').textContent = `FPS: ${fps} | Generation: ${gen}`;
      }
      
      requestAnimationFrame(animate);
    }

    // Event listeners
    document.getElementById('preset').addEventListener('change', (e) => {
      const p = presets[e.target.value];
      feed = p.feed;
      kill = p.kill;
      document.getElementById('feed').value = feed;
      document.getElementById('kill').value = kill;
      document.getElementById('feedVal').textContent = feed.toFixed(3);
      document.getElementById('killVal').textContent = kill.toFixed(3);
      initGrid();
      gen = 0;
    });

    document.getElementById('feed').addEventListener('input', (e) => {
      feed = parseFloat(e.target.value);
      document.getElementById('feedVal').textContent = feed.toFixed(3);
    });

    document.getElementById('kill').addEventListener('input', (e) => {
      kill = parseFloat(e.target.value);
      document.getElementById('killVal').textContent = kill.toFixed(3);
    });

    document.getElementById('speed').addEventListener('input', (e) => {
      iterations = parseInt(e.target.value);
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      initGrid();
      gen = 0;
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / 2);
      const y = Math.floor((e.clientY - rect.top) / 2);
      
      const radius = 8;
      for (let dy = -radius; dy <= radius; dy++) {
        for (let dx = -radius; dx <= radius; dx++) {
          if (dx*dx + dy*dy <= radius*radius) {
            const px = x + dx;
            const py = y + dy;
            if (px > 0 && px < gridWidth - 1 && py > 0 && py < gridHeight - 1) {
              const idx = (py * gridWidth + px) * 2 + 1;
              grid[idx] = 1.0;
            }
          }
        }
      }
    });

    window.addEventListener('resize', () => {
      resize();
    });

    // Init
    resize();
    initGrid();
    animate();
  </script>
</body>
</html>
