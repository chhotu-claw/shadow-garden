<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Falling Sand — Shadow's Garden</title>
<meta name="description" content="Cellular automata with sand, water, fire, oil, and acid. Click to draw.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body { margin: 0; overflow: hidden; background: #0a0a0f; }
  canvas { display: block; }
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    z-index: 10;
  }
  button {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
  }
  button:hover { background: rgba(255,255,255,0.2); }
  button.active { background: rgba(255,255,255,0.3); border-color: #fff; }
  .info {
    position: fixed;
    top: 20px;
    left: 20px;
    color: rgba(255,255,255,0.5);
    font-size: 13px;
    font-family: monospace;
  }
  .brush {
    position: fixed;
    top: 20px;
    right: 20px;
    color: rgba(255,255,255,0.5);
    font-size: 13px;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <canvas id="canvas"></canvas>
  <div class="info">Click + drag to draw • Scroll to change brush size</div>
  <div class="brush" id="brushInfo">Brush: 5</div>
  <div class="controls">
    <button id="sand" class="active">Sand</button>
    <button id="water">Water</button>
    <button id="fire">Fire</button>
    <button id="oil">Oil</button>
    <button id="acid">Acid</button>
    <button id="wall">Wall</button>
    <button id="eraser">Eraser</button>
    <button id="clear">Clear</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let grid = [];
    let particleSize = 4;
    let brushSize = 5;
    let currentType = 'sand';
    let mouseDown = false;
    
    const EMPTY = 0;
    const SAND = 1;
    const WATER = 2;
    const FIRE = 3;
    const OIL = 4;
    const ACID = 5;
    const WALL = 6;
    
    const colors = {
      [EMPTY]: '#0a0a0f',
      [SAND]: '#e6c229',
      [WATER]: '#4fa4f4',
      [FIRE]: '#ff6b35',
      [OIL]: '#2d2d2d',
      [ACID]: '#7fff00',
      [WALL]: '#888888'
    };
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      initGrid();
    }
    
    function initGrid() {
      grid = [];
      const cols = Math.ceil(width / particleSize);
      const rows = Math.ceil(height / particleSize);
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = EMPTY;
        }
      }
    }
    
    function draw(x, y, type) {
      const cols = Math.ceil(width / particleSize);
      const rows = Math.ceil(height / particleSize);
      
      for (let dy = -brushSize; dy <= brushSize; dy++) {
        for (let dx = -brushSize; dx <= brushSize; dx++) {
          if (dx*dx + dy*dy <= brushSize*brushSize) {
            const gx = Math.floor(x / particleSize) + dx;
            const gy = Math.floor(y / particleSize) + dy;
            if (gx >= 0 && gx < cols && gy >= 0 && gy < rows) {
              if (type === 'eraser') {
                grid[gy][gx] = EMPTY;
              } else if (type === 'wall') {
                grid[gy][gx] = WALL;
              } else {
                const types = { sand: SAND, water: WATER, fire: FIRE, oil: OIL, acid: ACID };
                grid[gy][gx] = types[type] || EMPTY;
              }
            }
          }
        }
      }
    }
    
    function update() {
      const cols = Math.ceil(width / particleSize);
      const rows = Math.ceil(height / particleSize);
      
      // Process bottom to top for falling particles
      for (let y = rows - 2; y >= 0; y--) {
        for (let x = 0; x < cols; x++) {
          const cell = grid[y][x];
          
          if (cell === EMPTY || cell === WALL) continue;
          
          // Random horizontal direction
          const dir = Math.random() < 0.5 ? 1 : -1;
          
          if (cell === SAND) {
            if (y + 1 < rows && grid[y+1][x] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x] = SAND;
            } else if (y + 1 < rows && x + dir >= 0 && x + dir < cols && grid[y+1][x+dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x+dir] = SAND;
            } else if (y + 1 < rows && x - dir >= 0 && x - dir < cols && grid[y+1][x-dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x-dir] = SAND;
            }
          }
          
          else if (cell === WATER) {
            if (y + 1 < rows && grid[y+1][x] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x] = WATER;
            } else if (y + 1 < rows && x + dir >= 0 && x + dir < cols && grid[y+1][x+dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x+dir] = WATER;
            } else if (x + dir >= 0 && x + dir < cols && grid[y][x+dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y][x+dir] = WATER;
            } else if (x - dir >= 0 && x - dir < cols && grid[y][x-dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y][x-dir] = WATER;
            }
          }
          
          else if (cell === FIRE) {
            // Fire rises and flickers
            if (Math.random() < 0.3) {
              grid[y][x] = EMPTY;
            }
            if (y - 1 >= 0 && grid[y-1][x] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y-1][x] = FIRE;
            } else if (y - 1 >= 0 && x + dir >= 0 && x + dir < cols && grid[y-1][x+dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y-1][x+dir] = FIRE;
            }
          }
          
          else if (cell === OIL) {
            if (y + 1 < rows && grid[y+1][x] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x] = OIL;
            } else if (y + 1 < rows && x + dir >= 0 && x + dir < cols && grid[y+1][x+dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y+1][x+dir] = OIL;
            } else if (x + dir >= 0 && x + dir < cols && grid[y][x+dir] === EMPTY) {
              grid[y][x] = EMPTY;
              grid[y][x+dir] = OIL;
            }
          }
          
          else if (cell === ACID) {
            // Acid dissolves everything
            if (y + 1 < rows && grid[y+1][x] !== EMPTY && grid[y+1][x] !== ACID && grid[y+1][x] !== WALL) {
              grid[y+1][x] = EMPTY;
              if (Math.random() < 0.1) grid[y][x] = EMPTY;
            }
          }
        }
      }
      
      // Fire spreads to oil
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (grid[y][x] === FIRE) {
            const dirs = [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
            for (const [dx, dy] of dirs) {
              const nx = x + dx, ny = y + dy;
              if (nx >= 0 && nx < cols && ny >= 0 && ny < rows && grid[ny][nx] === OIL) {
                if (Math.random() < 0.05) grid[ny][nx] = FIRE;
              }
            }
          }
        }
      }
    }
    
    function render() {
      const cols = Math.ceil(width / particleSize);
      const rows = Math.ceil(height / particleSize);
      
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = grid[y][x];
          if (cell !== EMPTY) {
            ctx.fillStyle = colors[cell];
            ctx.fillRect(x * particleSize, y * particleSize, particleSize, particleSize);
          }
        }
      }
    }
    
    function loop() {
      update();
      render();
      requestAnimationFrame(loop);
    }
    
    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      draw(e.clientX, e.clientY, currentType);
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (mouseDown) {
        draw(e.clientX, e.clientY, currentType);
      }
    });
    
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('mouseleave', () => mouseDown = false);
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      brushSize = Math.max(1, Math.min(20, brushSize + (e.deltaY > 0 ? -1 : 1)));
      document.getElementById('brushInfo').innerText = 'Brush: ' + brushSize;
    });
    
    const types = ['sand', 'water', 'fire', 'oil', 'acid', 'wall', 'eraser'];
    types.forEach(t => {
      document.getElementById(t).onclick = (e) => {
        types.forEach(type => document.getElementById(type).classList.remove('active'));
        e.target.classList.add('active');
        currentType = t;
      };
    });
    
    document.getElementById('clear').onclick = initGrid;
    
    window.addEventListener('resize', resize);
    resize();
    loop();
  </script>
</body>
</html>
