<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Marching Squares — Shadow's Garden</title>
<meta name="description">Contour lines from noise — marching squares algorithm visualized in real-time</meta>
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #0a0a0f;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
  }
  h1 {
    color: #e0e0e0;
    font-size: 1.8rem;
    margin-bottom: 5px;
    font-weight: 300;
  }
  .subtitle {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 20px;
  }
  canvas {
    border: 1px solid #222;
    border-radius: 4px;
    cursor: crosshair;
    box-shadow: 0 0 40px rgba(0,0,0,0.5);
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 15px;
    margin-top: 20px;
    justify-content: center;
    max-width: 800px;
  }
  .control-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
  }
  label {
    color: #888;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  input[type="range"] {
    width: 100px;
    accent-color: #666;
  }
  select, button {
    background: #1a1a20;
    color: #ccc;
    border: 1px solid #333;
    padding: 8px 14px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
  }
  button:hover {
    background: #252530;
    border-color: #555;
  }
  .presets {
    display: flex;
    gap: 5px;
  }
  .presets button {
    padding: 6px 10px;
    font-size: 0.75rem;
  }
  .stats {
    color: #555;
    font-size: 0.75rem;
    margin-top: 15px;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <h1>Marching Squares</h1>
  <div class="subtitle">Contour lines from noise • Drag to influence</div>
  <canvas id="canvas"></canvas>
  
  <div class="controls">
    <div class="control-group">
      <label>Resolution: <span id="resVal">4</span></label>
      <input type="range" id="resolution" min="2" max="10" value="4" step="1">
    </div>
    <div class="control-group">
      <label>Threshold</label>
      <input type="range" id="threshold" min="0.1" max="0.9" value="0.5" step="0.05">
    </div>
    <div class="control-group">
      <label>Noise Scale</label>
      <input type="range" id="noiseScale" min="0.5" max="5" value="2" step="0.1">
    </div>
    <div class="control-group">
      <label>Animation</label>
      <button id="animateBtn">Pause</button>
    </div>
    <div class="control-group">
      <label>Presets</label>
      <div class="presets">
        <button data-preset="blobs">Blobs</button>
        <button data-preset="stripes">Stripes</button>
        <button data-preset="rings">Rings</button>
        <button data-preset="cells">Cells</button>
      </div>
    </div>
  </div>
  
  <div class="stats" id="stats">FPS: 60</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let resolution = 4;
    let threshold = 0.5;
    let noiseScale = 2;
    let animating = true;
    let time = 0;
    let mouseX = 0, mouseY = 0, mouseDown = false;
    
    // Perlin noise implementation
    const permutation = [];
    for (let i = 0; i < 256; i++) permutation[i] = i;
    for (let i = 255; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [permutation[i], permutation[j]] = [permutation[j], permutation[i]];
    }
    const p = [...permutation, ...permutation];
    
    function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
    function lerp(a, b, t) { return a + t * (b - a); }
    function grad(hash, x, y) {
      const h = hash & 3;
      const u = h < 2 ? x : y;
      const v = h < 2 ? y : x;
      return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
    }
    
    function noise(x, y) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = fade(x);
      const v = fade(y);
      const A = p[X] + Y, B = p[X + 1] + Y;
      return lerp(
        lerp(grad(p[A], x, y), grad(p[B], x - 1, y), u),
        lerp(grad(p[A + 1], x, y - 1), grad(p[B + 1], x - 1, y - 1), u),
        v
      );
    }
    
    function fbm(x, y, octaves = 4) {
      let value = 0, amplitude = 0.5, frequency = 1;
      for (let i = 0; i < octaves; i++) {
        value += amplitude * noise(x * frequency, y * frequency);
        amplitude *= 0.5;
        frequency *= 2;
      }
      return value;
    }
    
    // Different noise patterns
    function getNoiseValue(x, y, preset) {
      const nx = x * noiseScale * 0.01;
      const ny = y * noiseScale * 0.01;
      const t = time * 0.0005;
      
      // Mouse influence
      const dx = x - mouseX;
      const dy = y - mouseY;
      const mouseInfluence = mouseDown ? Math.exp(-(dx*dx + dy*dy) / 20000) * 0.5 : 0;
      
      switch(preset) {
        case 'blobs':
          return fbm(nx + t, ny, 4) + mouseInfluence;
        case 'stripes':
          return Math.sin(nx * 3 + t * 2) * 0.5 + 0.5 + mouseInfluence * 0.3;
        case 'rings':
          const d = Math.sqrt((nx - 50) ** 2 + (ny - 50) ** 2);
          return (Math.sin(d * 2 - t * 3) * 0.5 + 0.5) + mouseInfluence * 0.3;
        case 'cells':
          return (fbm(nx * 2 + t * 0.5, ny * 2, 3) + 1) * 0.5 + mouseInfluence * 0.3;
        default:
          return fbm(nx + t, ny, 4) + mouseInfluence;
      }
    }
    
    let currentPreset = 'blobs';
    
    function resize() {
      width = Math.min(800, window.innerWidth - 40);
      height = Math.min(600, window.innerHeight - 250);
      canvas.width = width;
      canvas.height = height;
    }
    
    // Marching squares lookup table
    const edges = [
      [],           // 0: no edges
      [[0,1]],      // 1: bottom-left corner
      [[1,2]],      // 2: bottom-right corner
      [[0,2]],      // 3: cut bottom
      [[2,3]],      // 4: top-right corner
      [[0,1],[2,3]], // 5: saddle (ambiguous)
      [[1,3]],      // 6: cut vertical
      [[0,3]],      // 7: cut left
      [[0,3]],      // 8: cut left
      [[1,3]],      // 9: cut vertical
      [[0,1],[2,3]], // 10: saddle
      [[2,3]],      // 11: cut top
      [[0,2]],      // 12: cut bottom
      [[1,2]],      // 13: bottom-right
      [[0,1]],      // 14: bottom-left
      []            // 15: all filled
    ];
    
    // Edge midpoints
    function getEdgePoint(e, v0, v1, v2, v3) {
      const mid = 0.5;
      switch(e) {
        case 0: return { x: mid, y: 0 }; // top
        case 1: return { x: 1, y: mid }; // right
        case 2: return { x: mid, y: 1 }; // bottom
        case 3: return { x: 0, y: mid }; // left
      }
    }
    
    function march() {
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, width, height);
      
      const cellSize = resolution;
      const cols = Math.floor(width / cellSize);
      const rows = Math.floor(height / cellSize);
      
      // Get all corner values
      const grid = [];
      for (let j = 0; j <= rows; j++) {
        grid[j] = [];
        for (let i = 0; i <= cols; i++) {
          grid[j][i] = getNoiseValue(i * cellSize, j * cellSize, currentPreset);
        }
      }
      
      // Draw contours
      ctx.strokeStyle = '#00ff88';
      ctx.lineWidth = 1.5;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      
      for (let j = 0; j < rows; j++) {
        for (let i = 0; i < cols; i++) {
          const x = i * cellSize;
          const y = j * cellSize;
          
          // Get corner values
          const v0 = grid[j][i];     // top-left
          const v1 = grid[j][i+1];   // top-right
          const v2 = grid[j+1][i+1]; // bottom-right
          const v3 = grid[j+1][i];   // bottom-left
          
          // Calculate case
          let caseIndex = 0;
          if (v0 >= threshold) caseIndex |= 8;
          if (v1 >= threshold) caseIndex |= 4;
          if (v2 >= threshold) caseIndex |= 2;
          if (v3 >= threshold) caseIndex |= 1;
          
          const edgeList = edges[caseIndex];
          
          if (edgeList.length > 0) {
            // Interpolate edge points
            const points = edgeList.map(e => {
              const [a, b] = e;
              const p0 = a === 0 ? v0 : (a === 1 ? v1 : (a === 2 ? v2 : v3));
              const p1 = b === 0 ? v0 : (b === 1 ? v1 : (b === 2 ? v2 : v3));
              const t = (threshold - p0) / (p1 - p0);
              
              let ex, ey;
              if (a === 0) { ex = x + cellSize * 0.5; ey = y; }
              else if (a === 1) { ex = x + cellSize; ey = y + cellSize * 0.5; }
              else if (a === 2) { ex = x + cellSize * 0.5; ey = y + cellSize; }
              else { ex = x; ey = y + cellSize * 0.5; }
              
              let ex2, ey2;
              if (b === 0) { ex2 = x + cellSize * 0.5; ey2 = y; }
              else if (b === 1) { ex2 = x + cellSize; ey2 = y + cellSize * 0.5; }
              else if (b === 2) { ex2 = x + cellSize * 0.5; ey2 = y + cellSize; }
              else { ex2 = x; ey2 = y + cellSize * 0.5; }
              
              return {
                x: ex + (ex2 - ex) * t,
                y: ey + (ey2 - ey) * t
              };
            });
            
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            if (points[1]) {
              ctx.lineTo(points[1].x, points[1].y);
            }
            ctx.stroke();
          }
        }
      }
      
      // Draw mouse influence indicator
      if (mouseDown) {
        ctx.strokeStyle = 'rgba(255, 100, 100, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(mouseX, mouseY, 80, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    let lastTime = performance.now();
    let frames = 0;
    let fps = 60;
    
    function animate() {
      if (animating) {
        time += 16;
      }
      march();
      
      frames++;
      const now = performance.now();
      if (now - lastTime >= 1000) {
        fps = frames;
        frames = 0;
        lastTime = now;
        document.getElementById('stats').textContent = `FPS: ${fps}`;
      }
      
      requestAnimationFrame(animate);
    }
    
    // Event listeners
    document.getElementById('resolution').addEventListener('input', (e) => {
      resolution = parseInt(e.target.value);
      document.getElementById('resVal').textContent = resolution;
    });
    
    document.getElementById('threshold').addEventListener('input', (e) => {
      threshold = parseFloat(e.target.value);
    });
    
    document.getElementById('noiseScale').addEventListener('input', (e) => {
      noiseScale = parseFloat(e.target.value);
    });
    
    document.getElementById('animateBtn').addEventListener('click', (e) => {
      animating = !animating;
      e.target.textContent = animating ? 'Pause' : 'Play';
    });
    
    document.querySelectorAll('.presets button').forEach(btn => {
      btn.addEventListener('click', (e) => {
        currentPreset = e.target.dataset.preset;
        document.querySelectorAll('.presets button').forEach(b => b.style.background = '#1a1a20');
        e.target.style.background = '#333';
      });
    });
    
    canvas.addEventListener('mousedown', (e) => {
      mouseDown = true;
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });
    
    canvas.addEventListener('mouseup', () => { mouseDown = false; });
    canvas.addEventListener('mouseleave', () => { mouseDown = false; });
    
    window.addEventListener('resize', resize);
    
    // Init
    resize();
    animate();
  </script>
</body>
</html>
