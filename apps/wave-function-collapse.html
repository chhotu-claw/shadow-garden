<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wave Function Collapse — Shadow's Garden</title>
<meta name="description" content="Procedural cave generation using quantum mechanics-inspired entropy.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body { margin: 0; overflow: hidden; background: #0a0a0f; }
  canvas { display: block; }
  .controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    z-index: 10;
  }
  button {
    background: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-family: inherit;
    font-size: 13px;
    transition: all 0.2s;
  }
  button:hover { background: rgba(255,255,255,0.2); }
  .info {
    position: fixed;
    top: 20px;
    left: 20px;
    color: rgba(255,255,255,0.4);
    font-size: 13px;
    font-family: monospace;
  }
  .status {
    position: fixed;
    top: 20px;
    right: 20px;
    color: rgba(255,255,255,0.5);
    font-size: 13px;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <canvas id="canvas"></canvas>
  <div class="info">Click to step • Hold to auto-run • Space to reset</div>
  <div class="status" id="status">Collapsed: 0 / 1024</div>
  <div class="controls">
    <button id="step">Step</button>
    <button id="run">Auto Run</button>
    <button id="reset">Reset</button>
    <button id="p1">Caves</button>
    <button id="p2">Maze</button>
    <button id="p3">Islands</button>
    <button id="p4">Corridors</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let cellSize = 20;
    let cols, rows;
    let grid = [];
    let running = false;
    let interval = null;
    
    // Tile types: 0 = empty, 1 = wall
    const EMPTY = 0;
    const WALL = 1;
    
    // Adjacency rules: for each tile type, which neighbors are allowed
    let rules = {};
    
    const presets = {
      p1: { // Caves
        rules: {
          0: { 0: [0,1], 1: [0,1] },
          1: { 0: [0,1], 1: [1] }
        },
        init: () => {
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              grid[y][x] = Math.random() < 0.45 ? WALL : EMPTY;
            }
          }
        }
      },
      p2: { // Maze
        rules: {
          0: { 0: [0], 1: [1] },
          1: { 0: [0,1], 1: [0,1] }
        },
        init: () => {
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              if (x === 0 || x === cols-1 || y === 0 || y === rows-1) {
                grid[y][x] = WALL;
              } else if (x % 2 === 0 && y % 2 === 0) {
                grid[y][x] = WALL;
              } else {
                grid[y][x] = EMPTY;
              }
            }
          }
        }
      },
      p3: { // Islands
        rules: {
          0: { 0: [0], 1: [0,1] },
          1: { 0: [1], 1: [1] }
        },
        init: () => {
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const cx = cols/2, cy = rows/2;
              const dist = Math.hypot(x-cx, y-cy);
              const noise = (Math.random() - 0.5) * 10;
              grid[y][x] = dist + noise < cols/3 ? EMPTY : WALL;
            }
          }
        }
      },
      p4: { // Corridors
        rules: {
          0: { 0: [0], 1: [1] },
          1: { 0: [0,1], 1: [0,1] }
        },
        init: () => {
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              grid[y][x] = (x % 3 === 0 || y % 3 === 0) ? WALL : EMPTY;
            }
          }
        }
      }
    };
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      cols = Math.floor(width / cellSize);
      rows = Math.floor(height / cellSize);
      reset();
    }
    
    function reset() {
      grid = [];
      for (let y = 0; y < rows; y++) {
        grid[y] = [];
        for (let x = 0; x < cols; x++) {
          grid[y][x] = -1; // Unknown
        }
      }
      presets.p1.init();
      draw();
      updateStatus();
    }
    
    function getValidNeighbors(x, y, value) {
      const neighbors = [];
      const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
      
      for (const [dx, dy] of dirs) {
        const nx = x + dx, ny = y + dy;
        if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
          const nVal = grid[ny][nx];
          if (nVal !== -1) {
            if (!rules[value]) return [];
            const valid = rules[value][nVal];
            if (!valid || !valid.includes(value)) {
              return [];
            }
            neighbors.push(nVal);
          }
        }
      }
      return neighbors;
    }
    
    function propagate() {
      let changed = false;
      
      // Find cells with lowest entropy (most constrained)
      let minEntropy = 9;
      let candidates = [];
      
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (grid[y][x] !== -1) continue;
          
          // Count possible values based on neighbors
          let possible = [EMPTY, WALL];
          
          const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
          for (const [dx, dy] of dirs) {
            const nx = x + dx, ny = y + dy;
            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
              const nVal = grid[ny][nx];
              if (nVal !== -1) {
                possible = possible.filter(v => {
                  const rule = rules[v];
                  if (!rule) return false;
                  const valid = rule[nVal];
                  return valid && valid.includes(v);
                });
              }
            }
          }
          
          if (possible.length === 0) {
            // Dead end, pick random
            possible = [EMPTY, WALL];
          }
          
          if (possible.length < minEntropy) {
            minEntropy = possible.length;
            candidates = [{x, y, possible}];
          } else if (possible.length === minEntropy) {
            candidates.push({x, y, possible});
          }
        }
      }
      
      // Collapse lowest entropy cell
      if (candidates.length > 0) {
        const pick = candidates[Math.floor(Math.random() * candidates.length)];
        const value = pick.possible[Math.floor(Math.random() * pick.possible.length)];
        grid[pick.y][pick.x] = value;
        changed = true;
      }
      
      return changed;
    }
    
    function step() {
      propagate();
      draw();
      updateStatus();
    }
    
    function run() {
      if (running) {
        running = false;
        clearInterval(interval);
        document.getElementById('run').innerText = 'Auto Run';
      } else {
        running = true;
        interval = setInterval(step, 50);
        document.getElementById('run').innerText = 'Stop';
      }
    }
    
    function updateStatus() {
      let collapsed = 0;
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          if (grid[y][x] !== -1) collapsed++;
        }
      }
      document.getElementById('status').innerText = `Collapsed: ${collapsed} / ${cols * rows}`;
    }
    
    function draw() {
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, width, height);
      
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const val = grid[y][x];
          if (val === WALL) {
            ctx.fillStyle = '#2d3436';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
          } else if (val === EMPTY) {
            ctx.fillStyle = '#636e72';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
          } else {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(x * cellSize, y * cellSize, cellSize - 1, cellSize - 1);
          }
        }
      }
    }
    
    // Presets
    document.getElementById('p1').onclick = () => { rules = presets.p1.rules; presets.p1.init(); draw(); updateStatus(); };
    document.getElementById('p2').onclick = () => { rules = presets.p2.rules; presets.p2.init(); draw(); updateStatus(); };
    document.getElementById('p3').onclick = () => { rules = presets.p3.rules; presets.p3.init(); draw(); updateStatus(); };
    document.getElementById('p4').onclick = () => { rules = presets.p4.rules; presets.p4.init(); draw(); updateStatus(); };
    
    document.getElementById('step').onclick = step;
    document.getElementById('run').onclick = run;
    document.getElementById('reset').onclick = reset;
    
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') { reset(); e.preventDefault(); }
    });
    
    window.addEventListener('resize', resize);
    resize();
  </script>
</body>
</html>
