<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fluid Simulation — Shadow's Garden</title>
<meta name="description" content="Interactive fluid simulation with dye and velocity fields — click and drag to add fluid, watch it swirl and diffuse.">
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body {
    margin: 0;
    padding: 0;
    background: #0a0a0f;
    overflow: hidden;
  }
  canvas {
    display: block;
  }
  .controls {
    position: fixed;
    top: 20px;
    left: 20px;
    background: rgba(10, 10, 15, 0.85);
    border: 1px solid #333;
    border-radius: 8px;
    padding: 16px;
    color: #e0e0e0;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 12px;
    z-index: 100;
  }
  .controls h3 {
    margin: 0 0 12px 0;
    font-size: 14px;
    color: #fff;
    font-weight: 500;
  }
  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
  }
  .control-row label {
    color: #888;
  }
  .control-row input[type="range"] {
    width: 100px;
  }
  .control-row input[type="color"] {
    border: none;
    width: 30px;
    height: 20px;
    cursor: pointer;
  }
  .hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    color: #555;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    pointer-events: none;
  }
</style>
</head>
<body data-page-type="app">
  <canvas id="canvas"></canvas>
  
  <div class="controls">
    <h3>Fluid Sim</h3>
    <div class="control-row">
      <label>Diffusion</label>
      <input type="range" id="diffusion" min="0" max="0.002" step="0.0001" value="0.0001">
    </div>
    <div class="control-row">
      <label>Viscosity</label>
      <input type="range" id="viscosity" min="0" max="0.001" step="0.00005" value="0.0001">
    </div>
    <div class="control-row">
      <label>Dye Fade</label>
      <input type="range" id="fade" min="0" max="0.05" step="0.001" value="0.005">
    </div>
    <div class="control-row">
      <label>Dye Color</label>
      <input type="color" id="color" value="#00ffaa">
    </div>
    <div class="control-row">
      <label>Pressure</label>
      <input type="range" id="pressure" min="0.1" max="1" step="0.05" value="0.5">
    </div>
  </div>
  
  <div class="hint">Click and drag to add fluid · Scroll to add force</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let dye, velocityX, velocityY, density;
    let prevX, prevY;
    let isMouseDown = false;
    
    const N = 128;
    const scale = 4;
    
    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    }
    
    function init() {
      resize();
      const size = (N + 2) * (N + 2);
      dye = new Float32Array(size);
      velocityX = new Float32Array(size);
      velocityY = new Float32Array(size);
      density = new Float32Array(size);
    }
    
    function IX(x, y) {
      return x + (N + 2) * y;
    }
    
    function addSource(x, s, dt) {
      for (let i = 0; i < x.length; i++) {
        x[i] += dt * s[i];
      }
    }
    
    function setBnd(b, x) {
      for (let i = 1; i <= N; i++) {
        x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
        x[IX(N + 1, i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
        x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
        x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
      }
      x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
      x[IX(0, N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
      x[IX(N + 1, 0)] = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
      x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
    }
    
    function diffuse(b, x, x0, diff, dt) {
      const a = dt * diff * N * N;
      for (let k = 0; k < 4; k++) {
        for (let i = 1; i <= N; i++) {
          for (let j = 1; j <= N; j++) {
            x[IX(i, j)] = (x0[IX(i, j)] + a * (x[IX(i - 1, j)] + x[IX(i + 1, j)] + x[IX(i, j - 1)] + x[IX(i, j + 1)])) / (1 + 4 * a);
          }
        }
        setBnd(b, x);
      }
    }
    
    function advect(b, d, d0, velocX, velocY, dt) {
      const dt0 = dt * N;
      for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
          let x = i - dt0 * velocX[IX(i, j)];
          let y = j - dt0 * velocY[IX(i, j)];
          if (x < 0.5) x = 0.5;
          if (x > N + 0.5) x = N + 0.5;
          const i0 = Math.floor(x);
          const i1 = i0 + 1;
          if (y < 0.5) y = 0.5;
          if (y > N + 0.5) y = N + 0.5;
          const j0 = Math.floor(y);
          const j1 = j0 + 1;
          const s1 = x - i0;
          const s0 = 1 - s1;
          const t1 = y - j0;
          const t0 = 1 - t1;
          d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) + s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
        }
      }
      setBnd(b, d);
    }
    
    function project(velocX, velocY, p, div) {
      const h = 1.0 / N;
      for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
          div[IX(i, j)] = -0.5 * h * (velocX[IX(i + 1, j)] - velocX[IX(i - 1, j)] + velocY[IX(i, j + 1)] - velocY[IX(i, j - 1)]);
          p[IX(i, j)] = 0;
        }
      }
      setBnd(0, div);
      setBnd(0, p);
      
      for (let k = 0; k < 4; k++) {
        for (let i = 1; i <= N; i++) {
          for (let j = 1; j <= N; j++) {
            p[IX(i, j)] = (div[IX(i, j)] + p[IX(i - 1, j)] + p[IX(i + 1, j)] + p[IX(i, j - 1)] + p[IX(i, j + 1)]) / 4;
          }
        }
        setBnd(0, p);
      }
      
      for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
          velocX[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) / h;
          velocY[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) / h;
        }
      }
      setBnd(1, velocX);
      setBnd(2, velocY);
    }
    
    function velStep(vx, vy, x0, y0, visc, dt) {
      addSource(vx, x0, dt);
      addSource(vy, y0, dt);
      [vx0, x0] = [x0, vx];
      diffuse(1, vx0, x0, visc, dt);
      [vy0, y0] = [y0, vy];
      diffuse(2, vy0, y0, visc, dt);
      project(vx0, vy0, x0, y0);
      [vx0, x0] = [x0, vx];
      [vy0, y0] = [y0, vy];
      advect(1, vx, vx0, vx0, vy0, dt);
      advect(2, vy, vy0, vx0, vy0, dt);
      project(vx, vy, x0, y0);
    }
    
    function densStep(x, x0, vx, vy, diff, dt) {
      addSource(x, x0, dt);
      [x0, x] = [x, x0];
      diffuse(0, x, x0, diff, dt);
      [x0, x] = [x, x0];
      advect(0, x, x0, vx, vy, dt);
    }
    
    let vx = new Float32Array((N + 2) * (N + 2));
    let vy = new Float32Array((N + 2) * (N + 2));
    let vx0 = new Float32Array((N + 2) * (N + 2));
    let vy0 = new Float32Array((N + 2) * (N + 2));
    let s = new Float32Array((N + 2) * (N + 2));
    let density0 = new Float32Array((N + 2) * (N + 2));
    
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX || e.touches?.[0]?.clientX || 0);
      const y = (e.clientY || e.touches?.[0]?.clientY || 0);
      return {
        x: Math.floor((x / rect.width) * N) + 1,
        y: Math.floor((y / rect.height) * N) + 1
      };
    }
    
    canvas.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      const pos = getMousePos(e);
      prevX = pos.x;
      prevY = pos.y;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (!isMouseDown) return;
      const pos = getMousePos(e);
      
      const dx = pos.x - prevX;
      const dy = pos.y - prevY;
      
      const idx = IX(pos.x, pos.y);
      vx[idx] += dx * 50;
      vy[idx] += dy * 50;
      
      const color = document.getElementById('color').value;
      const r = parseInt(color.slice(1, 3), 16) / 255;
      const g = parseInt(color.slice(3, 5), 16) / 255;
      const b = parseInt(color.slice(5, 7), 16) / 255;
      
      const ci = idx * 4;
      density[idx] = 200;
      dye[ci] = r * 200;
      dye[ci + 1] = g * 200;
      dye[ci + 2] = b * 200;
      dye[ci + 3] = 200;
      
      prevX = pos.x;
      prevY = pos.y;
    });
    
    canvas.addEventListener('mouseup', () => isMouseDown = false);
    canvas.addEventListener('mouseleave', () => isMouseDown = false);
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      isMouseDown = true;
      const pos = getMousePos(e);
      prevX = pos.x;
      prevY = pos.y;
    });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isMouseDown) return;
      const pos = getMousePos(e);
      
      const dx = pos.x - prevX;
      const dy = pos.y - prevY;
      
      const idx = IX(pos.x, pos.y);
      vx[idx] += dx * 50;
      vy[idx] += dy * 50;
      
      const color = document.getElementById('color').value;
      const r = parseInt(color.slice(1, 3), 16) / 255;
      const g = parseInt(color.slice(3, 5), 16) / 255;
      const b = parseInt(color.slice(5, 7), 16) / 255;
      
      density[idx] = 200;
      dye[idx * 4] = r * 200;
      dye[idx * 4 + 1] = g * 200;
      dye[idx * 4 + 2] = b * 200;
      dye[idx * 4 + 3] = 200;
      
      prevX = pos.x;
      prevY = pos.y;
    });
    
    canvas.addEventListener('touchend', () => isMouseDown = false);
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const pos = getMousePos(e);
      const idx = IX(pos.x, pos.y);
      const force = e.deltaY > 0 ? -30 : 30;
      vx[idx] += force;
      vy[idx] += force;
    });
    
    window.addEventListener('resize', resize);
    
    const diffusionSlider = document.getElementById('diffusion');
    const viscositySlider = document.getElementById('viscosity');
    const fadeSlider = document.getElementById('fade');
    const pressureSlider = document.getElementById('pressure');
    
    function step() {
      const diff = parseFloat(diffusionSlider.value);
      const visc = parseFloat(viscositySlider.value);
      const fade = parseFloat(fadeSlider.value);
      const pressure = parseFloat(pressureSlider.value);
      
      velStep(vx, vy, vx0, vy0, visc * pressure, 0.1);
      densStep(density, density0, vx, vy, diff, 0.1);
      
      for (let i = 0; i < dye.length; i += 4) {
        dye[i] *= (1 - fade);
        dye[i + 1] *= (1 - fade);
        dye[i + 2] *= (1 - fade);
        dye[i + 3] *= (1 - fade);
      }
      
      for (let i = 0; i < density.length; i++) {
        density[i] *= (1 - fade);
      }
    }
    
    function render() {
      ctx.fillStyle = '#0a0a0f';
      ctx.fillRect(0, 0, width, height);
      
      const cellW = width / N;
      const cellH = height / N;
      
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;
      
      for (let j = 1; j <= N; j++) {
        for (let i = 1; i <= N; i++) {
          const d = density[IX(i, j)];
          if (d < 1) continue;
          
          const idx = IX(i, j) * 4;
          const r = dye[idx] || 0;
          const g = dye[idx + 1] || 0;
          const b = dye[idx + 2] || 0;
          
          const x0 = Math.floor((i - 1) * cellW);
          const y0 = Math.floor((j - 1) * cellH);
          const x1 = Math.floor(i * cellW);
          const y1 = Math.floor(j * cellH);
          
          for (let y = y0; y < y1 && y < height; y++) {
            for (let x = x0; x < x1 && x < width; x++) {
              const pi = (y * width + x) * 4;
              const alpha = Math.min(d / 255, 1);
              data[pi] = Math.min(255, data[pi] + r * alpha);
              data[pi + 1] = Math.min(255, data[pi + 1] + g * alpha);
              data[pi + 2] = Math.min(255, data[pi + 2] + b * alpha);
              data[pi + 3] = 255;
            }
          }
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
    }
    
    function loop() {
      step();
      render();
      requestAnimationFrame(loop);
    }
    
    init();
    loop();
  </script>
</body>
</html>
