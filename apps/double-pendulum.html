<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Double Pendulum — Shadow's Garden</title>
<meta name="description">Interactive double pendulum simulation — chaos in action. Drag to set angles, watch beautiful trajectories emerge.</meta>
<link rel="stylesheet" href="../style.css">
<script src="../nav.js" defer></script>
<style>
  body {
    display: flex;
    flex-direction: column;
    align-items: center;
    background: #0a0a0f;
    min-height: 100vh;
    padding: 20px;
    box-sizing: border-box;
  }
  h1 {
    color: #e0e0e0;
    font-size: 1.8rem;
    margin-bottom: 5px;
    font-weight: 300;
  }
  .subtitle {
    color: #666;
    font-size: 0.9rem;
    margin-bottom: 20px;
  }
  canvas {
    border: 1px solid #222;
    border-radius: 4px;
    cursor: grab;
    box-shadow: 0 0 40px rgba(0,0,0,0.5);
  }
  canvas:active {
    cursor: grabbing;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
    justify-content: center;
    align-items: center;
  }
  .control-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
  }
  label {
    color: #888;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  input[type="range"] {
    width: 120px;
    accent-color: #666;
  }
  select, button {
    background: #1a1a20;
    color: #ccc;
    border: 1px solid #333;
    padding: 8px 14px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.85rem;
    transition: all 0.2s;
  }
  button:hover {
    background: #252530;
    border-color: #555;
  }
  .value {
    color: #aaa;
    font-size: 0.8rem;
    min-width: 40px;
    text-align: center;
  }
  .instructions {
    color: #555;
    font-size: 0.75rem;
    margin-top: 15px;
    text-align: center;
  }
  .stats {
    color: #444;
    font-size: 0.7rem;
    margin-top: 10px;
    font-family: monospace;
  }
</style>
</head>
<body data-page-type="app">
  <h1>Double Pendulum</h1>
  <div class="subtitle">Chaos in action — drag to set initial angles</div>
  <canvas id="canvas"></canvas>
  
  <div class="controls">
    <div class="control-group">
      <label>Mass 1</label>
      <input type="range" id="m1" min="1" max="20" value="10">
      <span class="value" id="m1val">10</span>
    </div>
    <div class="control-group">
      <label>Mass 2</label>
      <input type="range" id="m2" min="1" max="20" value="10">
      <span class="value" id="m2val">10</span>
    </div>
    <div class="control-group">
      <label>Length 1</label>
      <input type="range" id="l1" min="50" max="200" value="150">
      <span class="value" id="l1val">150</span>
    </div>
    <div class="control-group">
      <label>Length 2</label>
      <input type="range" id="l2" min="50" max="200" value="150">
      <span class="value" id="l2val">150</span>
    </div>
    <div class="control-group">
      <label>Gravity</label>
      <input type="range" id="g" min="1" max="30" value="9.8" step="0.1">
      <span class="value" id="gval">9.8</span>
    </div>
    <div class="control-group">
      <label>Trace</label>
      <select id="traceMode">
        <option value="fade">Fade</option>
        <option value="clear">Clear</option>
        <option value="dot">Dots</option>
      </select>
    </div>
    <div class="control-group">
      <label>Actions</label>
      <button id="resetBtn">Reset</button>
    </div>
  </div>
  
  <div class="instructions">Drag the pendulum bobs to set initial angles, then release to simulate</div>
  <div class="stats" id="stats">Energy: 0.00</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width, height;
    let cx, cy;
    
    // Pendulum state
    let theta1 = Math.PI / 2;
    let theta2 = Math.PI / 2;
    let omega1 = 0;
    let omega2 = 0;
    
    // Parameters
    let m1 = 10, m2 = 10;
    let l1 = 150, l2 = 150;
    let g = 9.8;
    
    // Dragging state
    let dragging = 0; // 0=none, 1=mass1, 2=mass2
    let dragStartTheta1, dragStartTheta2;
    
    // Trail
    let trail = [];
    const maxTrail = 500;
    
    function resize() {
      width = Math.min(900, window.innerWidth - 40);
      height = Math.min(600, window.innerHeight - 280);
      canvas.width = width;
      canvas.height = height;
      cx = width / 2;
      cy = height / 3;
    }
    
    function getPositions() {
      const x1 = cx + l1 * Math.sin(theta1);
      const y1 = cy + l1 * Math.cos(theta1);
      const x2 = x1 + l2 * Math.sin(theta2);
      const y2 = y1 + l2 * Math.cos(theta2);
      return { x1, y1, x2, y2 };
    }
    
    // Equations of motion for double pendulum
    function derivatives(th1, th2, w1, w2) {
      const delta = th1 - th2;
      const den1 = (m1 + m2) * l1 - m2 * l1 * Math.cos(delta) * Math.cos(delta);
      const den2 = (l2 / l1) * den1;
      
      const dw1 = (m2 * l1 * w1 * w1 * Math.sin(delta) * Math.cos(delta) +
                  m2 * g * Math.sin(th2) * Math.cos(delta) +
                  m2 * l2 * w2 * w2 * Math.sin(delta) -
                  (m1 + m2) * g * Math.sin(th1)) / den1;
      
      const dw2 = (-m2 * l2 * w2 * w2 * Math.sin(delta) * Math.cos(delta) +
                  (m1 + m2) * g * Math.sin(th1) * Math.cos(delta) -
                  (m1 + m2) * l1 * w1 * w1 * Math.sin(delta) -
                  (m1 + m2) * g * Math.sin(th2)) / den2;
      
      return { dw1, dw2 };
    }
    
    // Runge-Kutta 4th order integration
    function update() {
      if (dragging) return;
      
      const dt = 0.1;
      
      // RK4
      const k1 = derivatives(theta1, theta2, omega1, omega2);
      const k2 = derivatives(theta1 + k1.dw1 * dt/2, theta2 + k1.dw2 * dt/2, 
                              omega1 + omega1 * dt/2, omega2 + omega2 * dt/2);
      const k3 = derivatives(theta1 + k2.dw1 * dt/2, theta2 + k2.dw2 * dt/2,
                              omega1 + k1.dw1 * dt/2, omega2 + k1.dw2 * dt/2);
      const k4 = derivatives(theta1 + k3.dw1 * dt, theta2 + k3.dw2 * dt,
                              omega1 + k2.dw1 * dt, omega2 + k2.dw2 * dt);
      
      theta1 += (k1.dw1 + 2*k2.dw1 + 2*k3.dw1 + k4.dw1) * dt / 6;
      theta2 += (k1.dw2 + 2*k2.dw2 + 2*k3.dw2 + k4.dw2) * dt / 6;
      omega1 += (k1.dw1 + 2*k2.dw1 + 2*k3.dw1 + k4.dw1) * dt / 6;
      omega2 += (k1.dw2 + 2*k2.dw2 + 2*k3.dw2 + k4.dw2) * dt / 6;
      
      // Damping
      omega1 *= 0.999;
      omega2 *= 0.999;
      
      // Energy (for stats)
      const ke = 0.5 * m1 * l1*l1 * omega1*omega1 + 
                 0.5 * m2 * (l1*l1*omega1*omega1 + l2*l2*omega2*omega2 + 
                 2*l1*l2*omega1*omega2*Math.cos(theta1-theta2));
      const pe = -m1*g*l1*Math.cos(theta1) - m2*g*(l1*Math.cos(theta1)+l2*Math.cos(theta2));
      const energy = ke + pe;
      document.getElementById('stats').textContent = `Energy: ${energy.toFixed(2)}`;
      
      // Trail
      const pos = getPositions();
      trail.push({ x: pos.x2, y: pos.y2 });
      if (trail.length > maxTrail) trail.shift();
    }
    
    function draw() {
      const traceMode = document.getElementById('traceMode').value;
      
      if (traceMode === 'fade') {
        ctx.fillStyle = 'rgba(10, 10, 15, 0.05)';
        ctx.fillRect(0, 0, width, height);
      } else if (traceMode === 'clear') {
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, width, height);
      }
      
      const pos = getPositions();
      
      // Draw trail
      if (trail.length > 1) {
        ctx.beginPath();
        ctx.moveTo(trail[0].x, trail[0].y);
        for (let i = 1; i < trail.length; i++) {
          ctx.lineTo(trail[i].x, trail[i].y);
        }
        const gradient = ctx.createLinearGradient(
          trail[0].x, trail[0].y, 
          trail[trail.length-1].x, trail[trail.length-1].y
        );
        gradient.addColorStop(0, 'rgba(100, 200, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(255, 100, 150, 0.8)');
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2;
        if (traceMode === 'dot') {
          ctx.setLineDash([2, 4]);
        } else {
          ctx.setLineDash([]);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // Draw pivot
      ctx.beginPath();
      ctx.arc(cx, cy, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#444';
      ctx.fill();
      
      // Draw rods
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(pos.x1, pos.y1);
      ctx.lineTo(pos.x2, pos.y2);
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw masses
      ctx.beginPath();
      ctx.arc(pos.x1, pos.y1, 10 + m1 * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = '#4a9eff';
      ctx.fill();
      ctx.strokeStyle = '#1a5acc';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.beginPath();
      ctx.arc(pos.x2, pos.y2, 10 + m2 * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = '#ff6b8a';
      ctx.fill();
      ctx.strokeStyle = '#cc4466';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
    
    function animate() {
      update();
      draw();
      requestAnimationFrame(animate);
    }
    
    // Event listeners
    function updateParam(id, val, param) {
      document.getElementById(id + 'val').textContent = val;
      window[param] = parseFloat(val);
    }
    
    document.getElementById('m1').addEventListener('input', (e) => updateParam('m1', e.target.value, 'm1'));
    document.getElementById('m2').addEventListener('input', (e) => updateParam('m2', e.target.value, 'm2'));
    document.getElementById('l1').addEventListener('input', (e) => updateParam('l1', e.target.value, 'l1'));
    document.getElementById('l2').addEventListener('input', (e) => updateParam('l2', e.target.value, 'l2'));
    document.getElementById('g').addEventListener('input', (e) => updateParam('g', e.target.value, 'g'));
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      theta1 = Math.PI / 2;
      theta2 = Math.PI / 2;
      omega1 = 0;
      omega2 = 0;
      trail = [];
    });
    
    // Mouse/touch dragging
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }
    
    function dist(x1, y1, x2, y2) {
      return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
    }
    
    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      const p = getPositions();
      
      if (dist(pos.x, pos.y, p.x1, p.y1) < 30) {
        dragging = 1;
        canvas.style.cursor = 'grabbing';
      } else if (dist(pos.x, pos.y, p.x2, p.y2) < 30) {
        dragging = 2;
        canvas.style.cursor = 'grabbing';
      }
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const pos = getMousePos(e);
      
      if (dragging === 1) {
        theta1 = Math.atan2(pos.x - cx, pos.y - cy);
      } else if (dragging === 2) {
        const p = getPositions();
        theta2 = Math.atan2(pos.x - p.x1, pos.y - p.y1);
      }
      
      // Clear trail when dragging
      trail = [];
    });
    
    canvas.addEventListener('mouseup', () => {
      if (dragging) {
        dragging = 0;
        canvas.style.cursor = 'grab';
        omega1 = 0;
        omega2 = 0;
      }
    });
    
    canvas.addEventListener('mouseleave', () => {
      if (dragging) {
        dragging = 0;
        canvas.style.cursor = 'grab';
        omega1 = 0;
        omega2 = 0;
      }
    });
    
    window.addEventListener('resize', resize);
    
    // Init
    resize();
    animate();
  </script>
</body>
</html>
